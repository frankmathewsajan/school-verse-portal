# 🚀 Complete Supabase Setup Guide for Next.js Projects

## 📋 Overview
This comprehensive guide will help you set up Supabase backend integration in a new Next.js project with authentication, database operations, image uploads, and type safety.

---

## 🔧 Prerequisites

- Node.js 18+ installed
- Next.js project initialized
- Supabase account (https://supabase.com)
- Basic knowledge of TypeScript and React

---

## 📦 1. Package Installation

### Core Supabase Dependencies
```bash
npm install @supabase/supabase-js @supabase/auth-helpers-nextjs
npm install @supabase/auth-helpers-react @supabase/auth-ui-react
npm install @supabase/auth-ui-shared

# For TypeScript support
npm install -D @types/node

# Optional: React Query for better data fetching
npm install @tanstack/react-query @tanstack/react-query-devtools

# For form handling (recommended)
npm install react-hook-form @hookform/resolvers zod

# For file uploads
npm install react-dropzone

# For UI components (optional but recommended)
npm install @radix-ui/react-dialog @radix-ui/react-button
npm install class-variance-authority clsx tailwind-merge
```

---

## 🏗️ 2. Project Structure

Create the following directory structure in your Next.js project:

```
src/
├── lib/
│   ├── supabase/
│   │   ├── client.ts          # Client-side Supabase client
│   │   ├── server.ts          # Server-side Supabase client
│   │   ├── types.ts           # Generated database types
│   │   └── middleware.ts      # Auth middleware
├── services/
│   ├── auth.ts                # Authentication service
│   ├── database.ts            # Database operations
│   └── storage.ts             # File upload service
├── components/
│   ├── auth/
│   │   ├── LoginForm.tsx
│   │   ├── SignupForm.tsx
│   │   └── AuthProvider.tsx
│   ├── ui/
│   │   ├── FileUpload.tsx
│   │   └── ImageUpload.tsx
├── app/
│   ├── auth/
│   │   ├── login/
│   │   └── signup/
│   ├── dashboard/
│   └── api/
│       └── auth/
│           └── callback/
│               └── route.ts
├── middleware.ts              # Next.js middleware for auth
└── types/
    └── database.ts            # Custom type definitions
```

---

## 🌐 3. Environment Configuration

### Create `.env.local`
```bash
# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL=https://your-project-id.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# Next.js Configuration
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=your-nextauth-secret

# Optional: Custom configuration
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

### Add to `.env.example`
```bash
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=
NEXTAUTH_URL=
NEXTAUTH_SECRET=
```

---

## 🔐 4. Supabase Client Setup

### `src/lib/supabase/client.ts` (Client-side)
```typescript
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'
import type { Database } from './types'

export const createClient = () => {
  return createClientComponentClient<Database>()
}

// Export a singleton instance
export const supabase = createClient()
```

### `src/lib/supabase/server.ts` (Server-side)
```typescript
import { createServerComponentClient, createServerActionClient } from '@supabase/auth-helpers-nextjs'
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import type { Database } from './types'

// For Server Components
export const createServerClient = () => {
  const cookieStore = cookies()
  return createServerComponentClient<Database>({ cookies: () => cookieStore })
}

// For Server Actions
export const createServerActionClient = () => {
  const cookieStore = cookies()
  return createServerActionClient<Database>({ cookies: () => cookieStore })
}

// For Route Handlers (API routes)
export const createRouteHandlerClient = () => {
  const cookieStore = cookies()
  return createRouteHandlerClient<Database>({ cookies: () => cookieStore })
}
```

### `src/lib/supabase/types.ts` (Generated Types)
```typescript
// This file is generated by: npx supabase gen types typescript --project-id your-project-id
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      // Your table definitions will be generated here
      profiles: {
        Row: {
          id: string
          username: string | null
          full_name: string | null
          avatar_url: string | null
          website: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id: string
          username?: string | null
          full_name?: string | null
          avatar_url?: string | null
          website?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          username?: string | null
          full_name?: string | null
          avatar_url?: string | null
          website?: string | null
          created_at?: string
          updated_at?: string
        }
      }
      // Add more tables as needed
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      [_ in never]: never
    }
  }
}
```

---

## 🔒 5. Authentication Setup

### `src/services/auth.ts`
```typescript
import { createClient } from '@/lib/supabase/client'
import type { User, Session, AuthError } from '@supabase/supabase-js'

export class AuthService {
  private static supabase = createClient()

  // Sign up with email and password
  static async signUp(email: string, password: string, options?: {
    firstName?: string
    lastName?: string
    username?: string
  }) {
    try {
      const { data, error } = await this.supabase.auth.signUp({
        email,
        password,
        options: {
          data: {
            first_name: options?.firstName,
            last_name: options?.lastName,
            username: options?.username,
          }
        }
      })

      if (error) throw error
      return { user: data.user, session: data.session, error: null }
    } catch (error) {
      return { user: null, session: null, error: error as AuthError }
    }
  }

  // Sign in with email and password
  static async signIn(email: string, password: string) {
    try {
      const { data, error } = await this.supabase.auth.signInWithPassword({
        email,
        password
      })

      if (error) throw error
      return { user: data.user, session: data.session, error: null }
    } catch (error) {
      return { user: null, session: null, error: error as AuthError }
    }
  }

  // Sign in with OAuth (Google, GitHub, etc.)
  static async signInWithOAuth(provider: 'google' | 'github' | 'discord') {
    try {
      const { data, error } = await this.supabase.auth.signInWithOAuth({
        provider,
        options: {
          redirectTo: `${window.location.origin}/auth/callback`
        }
      })

      if (error) throw error
      return { error: null }
    } catch (error) {
      return { error: error as AuthError }
    }
  }

  // Sign out
  static async signOut() {
    try {
      const { error } = await this.supabase.auth.signOut()
      if (error) throw error
      return { error: null }
    } catch (error) {
      return { error: error as AuthError }
    }
  }

  // Get current user
  static async getCurrentUser(): Promise<User | null> {
    try {
      const { data: { user }, error } = await this.supabase.auth.getUser()
      if (error) throw error
      return user
    } catch (error) {
      console.error('Error getting current user:', error)
      return null
    }
  }

  // Get current session
  static async getCurrentSession(): Promise<Session | null> {
    try {
      const { data: { session }, error } = await this.supabase.auth.getSession()
      if (error) throw error
      return session
    } catch (error) {
      console.error('Error getting current session:', error)
      return null
    }
  }

  // Listen to auth changes
  static onAuthStateChange(callback: (event: string, session: Session | null) => void) {
    return this.supabase.auth.onAuthStateChange(callback)
  }

  // Reset password
  static async resetPassword(email: string) {
    try {
      const { error } = await this.supabase.auth.resetPasswordForEmail(email, {
        redirectTo: `${window.location.origin}/auth/reset-password`
      })
      if (error) throw error
      return { error: null }
    } catch (error) {
      return { error: error as AuthError }
    }
  }

  // Update password
  static async updatePassword(newPassword: string) {
    try {
      const { error } = await this.supabase.auth.updateUser({
        password: newPassword
      })
      if (error) throw error
      return { error: null }
    } catch (error) {
      return { error: error as AuthError }
    }
  }
}
```

### `src/components/auth/AuthProvider.tsx`
```typescript
'use client'

import { createContext, useContext, useEffect, useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import type { User, Session } from '@supabase/supabase-js'

interface AuthContextType {
  user: User | null
  session: Session | null
  loading: boolean
  signIn: (email: string, password: string) => Promise<any>
  signUp: (email: string, password: string) => Promise<any>
  signOut: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [session, setSession] = useState<Session | null>(null)
  const [loading, setLoading] = useState(true)
  const supabase = createClient()

  useEffect(() => {
    // Get initial session
    const getInitialSession = async () => {
      const { data: { session } } = await supabase.auth.getSession()
      setSession(session)
      setUser(session?.user ?? null)
      setLoading(false)
    }

    getInitialSession()

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        setSession(session)
        setUser(session?.user ?? null)
        setLoading(false)
      }
    )

    return () => subscription?.unsubscribe()
  }, [supabase.auth])

  const signIn = async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })
    return { data, error }
  }

  const signUp = async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
    })
    return { data, error }
  }

  const signOut = async () => {
    await supabase.auth.signOut()
  }

  const value = {
    user,
    session,
    loading,
    signIn,
    signUp,
    signOut,
  }

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}
```

### `src/components/auth/LoginForm.tsx`
```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { useAuth } from './AuthProvider'

export function LoginForm() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')
  
  const { signIn } = useAuth()
  const router = useRouter()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setLoading(true)
    setError('')

    const { error } = await signIn(email, password)
    
    if (error) {
      setError(error.message)
    } else {
      router.push('/dashboard')
    }
    
    setLoading(false)
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label htmlFor="email" className="block text-sm font-medium">
          Email
        </label>
        <input
          id="email"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
          className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md"
        />
      </div>
      
      <div>
        <label htmlFor="password" className="block text-sm font-medium">
          Password
        </label>
        <input
          id="password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
          className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md"
        />
      </div>

      {error && (
        <div className="text-red-600 text-sm">{error}</div>
      )}

      <button
        type="submit"
        disabled={loading}
        className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 disabled:opacity-50"
      >
        {loading ? 'Signing in...' : 'Sign In'}
      </button>
    </form>
  )
}
```

---

## 🗄️ 6. Database Operations

### `src/services/database.ts`
```typescript
import { createClient } from '@/lib/supabase/client'
import type { Database } from '@/lib/supabase/types'

type Profile = Database['public']['Tables']['profiles']['Row']
type ProfileInsert = Database['public']['Tables']['profiles']['Insert']
type ProfileUpdate = Database['public']['Tables']['profiles']['Update']

export class DatabaseService {
  private static supabase = createClient()

  // Profile operations
  static async getProfile(userId: string): Promise<Profile | null> {
    try {
      const { data, error } = await this.supabase
        .from('profiles')
        .select('*')
        .eq('id', userId)
        .single()

      if (error) throw error
      return data
    } catch (error) {
      console.error('Error fetching profile:', error)
      return null
    }
  }

  static async createProfile(profile: ProfileInsert): Promise<Profile | null> {
    try {
      const { data, error } = await this.supabase
        .from('profiles')
        .insert([profile])
        .select()
        .single()

      if (error) throw error
      return data
    } catch (error) {
      console.error('Error creating profile:', error)
      return null
    }
  }

  static async updateProfile(userId: string, updates: ProfileUpdate): Promise<Profile | null> {
    try {
      const { data, error } = await this.supabase
        .from('profiles')
        .update(updates)
        .eq('id', userId)
        .select()
        .single()

      if (error) throw error
      return data
    } catch (error) {
      console.error('Error updating profile:', error)
      return null
    }
  }

  static async deleteProfile(userId: string): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('profiles')
        .delete()
        .eq('id', userId)

      if (error) throw error
      return true
    } catch (error) {
      console.error('Error deleting profile:', error)
      return false
    }
  }

  // Generic CRUD operations
  static async create<T>(
    table: string,
    data: Partial<T>
  ): Promise<T | null> {
    try {
      const { data: result, error } = await this.supabase
        .from(table)
        .insert([data])
        .select()
        .single()

      if (error) throw error
      return result as T
    } catch (error) {
      console.error(`Error creating ${table}:`, error)
      return null
    }
  }

  static async read<T>(
    table: string,
    id: string,
    idColumn: string = 'id'
  ): Promise<T | null> {
    try {
      const { data, error } = await this.supabase
        .from(table)
        .select('*')
        .eq(idColumn, id)
        .single()

      if (error) throw error
      return data as T
    } catch (error) {
      console.error(`Error reading ${table}:`, error)
      return null
    }
  }

  static async update<T>(
    table: string,
    id: string,
    updates: Partial<T>,
    idColumn: string = 'id'
  ): Promise<T | null> {
    try {
      const { data, error } = await this.supabase
        .from(table)
        .update(updates)
        .eq(idColumn, id)
        .select()
        .single()

      if (error) throw error
      return data as T
    } catch (error) {
      console.error(`Error updating ${table}:`, error)
      return null
    }
  }

  static async delete(
    table: string,
    id: string,
    idColumn: string = 'id'
  ): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from(table)
        .delete()
        .eq(idColumn, id)

      if (error) throw error
      return true
    } catch (error) {
      console.error(`Error deleting from ${table}:`, error)
      return false
    }
  }

  // Query with filters
  static async query<T>(
    table: string,
    options?: {
      select?: string
      filter?: { column: string; operator: string; value: any }[]
      order?: { column: string; ascending?: boolean }
      limit?: number
      offset?: number
    }
  ): Promise<T[]> {
    try {
      let query = this.supabase.from(table)

      if (options?.select) {
        query = query.select(options.select)
      } else {
        query = query.select('*')
      }

      if (options?.filter) {
        options.filter.forEach(({ column, operator, value }) => {
          query = query.filter(column, operator, value)
        })
      }

      if (options?.order) {
        query = query.order(options.order.column, {
          ascending: options.order.ascending ?? true
        })
      }

      if (options?.limit) {
        query = query.limit(options.limit)
      }

      if (options?.offset) {
        query = query.range(options.offset, options.offset + (options.limit || 10) - 1)
      }

      const { data, error } = await query

      if (error) throw error
      return (data as T[]) || []
    } catch (error) {
      console.error(`Error querying ${table}:`, error)
      return []
    }
  }
}
```

---

## 📁 7. File Upload & Storage

### `src/services/storage.ts`
```typescript
import { createClient } from '@/lib/supabase/client'

export class StorageService {
  private static supabase = createClient()

  // Upload file to storage bucket
  static async uploadFile(
    bucket: string,
    file: File,
    path?: string,
    options?: {
      cacheControl?: string
      upsert?: boolean
    }
  ): Promise<string | null> {
    try {
      // Generate unique filename if path not provided
      const fileName = path || `${Date.now()}_${Math.random().toString(36).substring(2)}.${file.name.split('.').pop()}`
      
      const { data, error } = await this.supabase.storage
        .from(bucket)
        .upload(fileName, file, {
          cacheControl: options?.cacheControl || '3600',
          upsert: options?.upsert || false
        })

      if (error) throw error

      // Get public URL
      const { data: publicData } = this.supabase.storage
        .from(bucket)
        .getPublicUrl(fileName)

      return publicData.publicUrl
    } catch (error) {
      console.error('Error uploading file:', error)
      return null
    }
  }

  // Upload image with validation
  static async uploadImage(
    bucket: string,
    file: File,
    path?: string,
    maxSize: number = 5 * 1024 * 1024 // 5MB default
  ): Promise<string | null> {
    try {
      // Validate file type
      if (!file.type.startsWith('image/')) {
        throw new Error('File must be an image')
      }

      // Validate file size
      if (file.size > maxSize) {
        throw new Error(`File size must be less than ${maxSize / 1024 / 1024}MB`)
      }

      // Validate image format
      const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp']
      if (!allowedTypes.includes(file.type)) {
        throw new Error('Invalid image format. Allowed: JPEG, PNG, GIF, WebP')
      }

      return await this.uploadFile(bucket, file, path)
    } catch (error) {
      console.error('Error uploading image:', error)
      return null
    }
  }

  // Upload document with validation
  static async uploadDocument(
    bucket: string,
    file: File,
    path?: string,
    maxSize: number = 50 * 1024 * 1024 // 50MB default
  ): Promise<string | null> {
    try {
      // Validate file size
      if (file.size > maxSize) {
        throw new Error(`File size must be less than ${maxSize / 1024 / 1024}MB`)
      }

      // Validate document format
      const allowedTypes = [
        'application/pdf',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'application/vnd.ms-excel',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-powerpoint',
        'application/vnd.openxmlformats-officedocument.presentationml.presentation',
        'text/plain',
        'application/zip'
      ]

      if (!allowedTypes.includes(file.type)) {
        throw new Error('Invalid document format')
      }

      return await this.uploadFile(bucket, file, path)
    } catch (error) {
      console.error('Error uploading document:', error)
      return null
    }
  }

  // Delete file from storage
  static async deleteFile(bucket: string, path: string): Promise<boolean> {
    try {
      const { error } = await this.supabase.storage
        .from(bucket)
        .remove([path])

      if (error) throw error
      return true
    } catch (error) {
      console.error('Error deleting file:', error)
      return false
    }
  }

  // List files in bucket
  static async listFiles(
    bucket: string,
    path: string = '',
    options?: {
      limit?: number
      offset?: number
      sortBy?: { column: string; order: 'asc' | 'desc' }
    }
  ) {
    try {
      const { data, error } = await this.supabase.storage
        .from(bucket)
        .list(path, options)

      if (error) throw error
      return data
    } catch (error) {
      console.error('Error listing files:', error)
      return []
    }
  }

  // Get file URL
  static getFileUrl(bucket: string, path: string): string {
    const { data } = this.supabase.storage
      .from(bucket)
      .getPublicUrl(path)

    return data.publicUrl
  }

  // Download file
  static async downloadFile(bucket: string, path: string): Promise<Blob | null> {
    try {
      const { data, error } = await this.supabase.storage
        .from(bucket)
        .download(path)

      if (error) throw error
      return data
    } catch (error) {
      console.error('Error downloading file:', error)
      return null
    }
  }
}
```

### `src/components/ui/FileUpload.tsx`
```typescript
'use client'

import { useCallback, useState } from 'react'
import { useDropzone } from 'react-dropzone'
import { StorageService } from '@/services/storage'

interface FileUploadProps {
  bucket: string
  accept?: Record<string, string[]>
  maxSize?: number
  multiple?: boolean
  onUpload?: (urls: string[]) => void
  onError?: (error: string) => void
  className?: string
}

export function FileUpload({
  bucket,
  accept,
  maxSize = 5 * 1024 * 1024, // 5MB default
  multiple = false,
  onUpload,
  onError,
  className = ''
}: FileUploadProps) {
  const [uploading, setUploading] = useState(false)
  const [uploadedFiles, setUploadedFiles] = useState<string[]>([])

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    if (acceptedFiles.length === 0) return

    setUploading(true)
    const uploadPromises = acceptedFiles.map(async (file) => {
      try {
        if (file.type.startsWith('image/')) {
          return await StorageService.uploadImage(bucket, file, undefined, maxSize)
        } else {
          return await StorageService.uploadDocument(bucket, file, undefined, maxSize)
        }
      } catch (error) {
        onError?.(error instanceof Error ? error.message : 'Upload failed')
        return null
      }
    })

    try {
      const results = await Promise.all(uploadPromises)
      const successfulUploads = results.filter((url): url is string => url !== null)
      
      setUploadedFiles(prev => [...prev, ...successfulUploads])
      onUpload?.(successfulUploads)
    } catch (error) {
      onError?.(error instanceof Error ? error.message : 'Upload failed')
    } finally {
      setUploading(false)
    }
  }, [bucket, maxSize, onUpload, onError])

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept,
    maxSize,
    multiple
  })

  return (
    <div className={className}>
      <div
        {...getRootProps()}
        className={`
          border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors
          ${isDragActive ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-gray-400'}
          ${uploading ? 'pointer-events-none opacity-50' : ''}
        `}
      >
        <input {...getInputProps()} />
        {uploading ? (
          <p>Uploading...</p>
        ) : isDragActive ? (
          <p>Drop the files here...</p>
        ) : (
          <p>Drag & drop files here, or click to select files</p>
        )}
      </div>

      {uploadedFiles.length > 0 && (
        <div className="mt-4">
          <h4 className="font-medium">Uploaded Files:</h4>
          <ul className="mt-2 space-y-1">
            {uploadedFiles.map((url, index) => (
              <li key={index} className="text-sm text-green-600">
                File uploaded successfully
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  )
}
```

### `src/components/ui/ImageUpload.tsx`
```typescript
'use client'

import { useState } from 'react'
import Image from 'next/image'
import { FileUpload } from './FileUpload'

interface ImageUploadProps {
  bucket: string
  currentImage?: string
  onImageChange?: (url: string) => void
  onError?: (error: string) => void
  className?: string
  maxSize?: number
}

export function ImageUpload({
  bucket,
  currentImage,
  onImageChange,
  onError,
  className = '',
  maxSize = 5 * 1024 * 1024 // 5MB default
}: ImageUploadProps) {
  const [imageUrl, setImageUrl] = useState(currentImage || '')

  const handleUpload = (urls: string[]) => {
    if (urls.length > 0) {
      const newImageUrl = urls[0]
      setImageUrl(newImageUrl)
      onImageChange?.(newImageUrl)
    }
  }

  return (
    <div className={className}>
      {imageUrl && (
        <div className="mb-4">
          <Image
            src={imageUrl}
            alt="Uploaded image"
            width={200}
            height={200}
            className="rounded-lg object-cover"
          />
        </div>
      )}
      
      <FileUpload
        bucket={bucket}
        accept={{ 'image/*': ['.png', '.jpg', '.jpeg', '.gif', '.webp'] }}
        maxSize={maxSize}
        multiple={false}
        onUpload={handleUpload}
        onError={onError}
      />
    </div>
  )
}
```

---

## 🛡️ 8. Middleware & Route Protection

### `src/middleware.ts` (Next.js Middleware)
```typescript
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req, res })

  // Refresh session if expired
  const {
    data: { session },
  } = await supabase.auth.getSession()

  // Protect admin routes
  if (req.nextUrl.pathname.startsWith('/admin') || req.nextUrl.pathname.startsWith('/dashboard')) {
    if (!session) {
      return NextResponse.redirect(new URL('/auth/login', req.url))
    }
  }

  // Redirect authenticated users away from auth pages
  if (req.nextUrl.pathname.startsWith('/auth')) {
    if (session) {
      return NextResponse.redirect(new URL('/dashboard', req.url))
    }
  }

  return res
}

export const config = {
  matcher: ['/admin/:path*', '/dashboard/:path*', '/auth/:path*']
}
```

### `src/app/api/auth/callback/route.ts` (Auth Callback Handler)
```typescript
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function GET(request: NextRequest) {
  const requestUrl = new URL(request.url)
  const code = requestUrl.searchParams.get('code')

  if (code) {
    const cookieStore = cookies()
    const supabase = createRouteHandlerClient({ cookies: () => cookieStore })
    await supabase.auth.exchangeCodeForSession(code)
  }

  // URL to redirect to after sign in process completes
  return NextResponse.redirect(requestUrl.origin)
}
```

---

## 🗃️ 9. Database Schema & Setup

### SQL Schema Example
```sql
-- Enable necessary extensions
create extension if not exists "uuid-ossp";

-- Create profiles table
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  username text unique,
  full_name text,
  avatar_url text,
  website text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create posts table (example)
create table posts (
  id uuid default uuid_generate_v4() primary key,
  title text not null,
  content text,
  author_id uuid references profiles(id) on delete cascade not null,
  published boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable Row Level Security
alter table profiles enable row level security;
alter table posts enable row level security;

-- Create policies
create policy "Public profiles are viewable by everyone" 
  on profiles for select 
  using (true);

create policy "Users can insert their own profile" 
  on profiles for insert 
  with check (auth.uid() = id);

create policy "Users can update own profile" 
  on profiles for update 
  using (auth.uid() = id);

create policy "Users can view all posts" 
  on posts for select 
  using (true);

create policy "Users can insert their own posts" 
  on posts for insert 
  with check (auth.uid() = author_id);

create policy "Users can update their own posts" 
  on posts for update 
  using (auth.uid() = author_id);

-- Create storage buckets
insert into storage.buckets (id, name, public) values ('avatars', 'avatars', true);
insert into storage.buckets (id, name, public) values ('post-images', 'post-images', true);

-- Create storage policies
create policy "Avatar images are publicly accessible" 
  on storage.objects for select 
  using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar" 
  on storage.objects for insert 
  with check (bucket_id = 'avatars');

create policy "Anyone can update their own avatar" 
  on storage.objects for update 
  using (auth.uid()::text = (storage.foldername(name))[1]);
```

---

## 🔧 10. Configuration Files

### `next.config.js`
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverActions: true,
  },
  images: {
    domains: [
      'your-project-id.supabase.co', // Add your Supabase domain
      'lh3.googleusercontent.com', // For Google OAuth avatars
      'avatars.githubusercontent.com', // For GitHub OAuth avatars
    ],
  },
}

module.exports = nextConfig
```

### `tsconfig.json` (Add path mapping)
```json
{
  "compilerOptions": {
    // ... other options
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@/lib/*": ["./src/lib/*"],
      "@/components/*": ["./src/components/*"],
      "@/services/*": ["./src/services/*"],
      "@/types/*": ["./src/types/*"]
    }
  }
}
```

---

## 🚀 11. Usage Examples

### `src/app/layout.tsx` (Root Layout)
```typescript
import { AuthProvider } from '@/components/auth/AuthProvider'
import './globals.css'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <AuthProvider>
          {children}
        </AuthProvider>
      </body>
    </html>
  )
}
```

### `src/app/dashboard/page.tsx` (Protected Page)
```typescript
'use client'

import { useAuth } from '@/components/auth/AuthProvider'
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'

export default function Dashboard() {
  const { user, loading, signOut } = useAuth()
  const router = useRouter()

  useEffect(() => {
    if (!loading && !user) {
      router.push('/auth/login')
    }
  }, [user, loading, router])

  if (loading) {
    return <div>Loading...</div>
  }

  if (!user) {
    return null
  }

  return (
    <div className="p-8">
      <h1 className="text-2xl font-bold mb-4">Dashboard</h1>
      <p>Welcome, {user.email}!</p>
      <button 
        onClick={signOut}
        className="mt-4 bg-red-600 text-white px-4 py-2 rounded"
      >
        Sign Out
      </button>
    </div>
  )
}
```

### Example Component with Database Operations
```typescript
'use client'

import { useState, useEffect } from 'react'
import { DatabaseService } from '@/services/database'
import { useAuth } from '@/components/auth/AuthProvider'

export default function ProfilePage() {
  const { user } = useAuth()
  const [profile, setProfile] = useState(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    if (user) {
      loadProfile()
    }
  }, [user])

  const loadProfile = async () => {
    if (!user) return
    
    const profileData = await DatabaseService.getProfile(user.id)
    setProfile(profileData)
    setLoading(false)
  }

  const updateProfile = async (updates: any) => {
    if (!user) return
    
    const updatedProfile = await DatabaseService.updateProfile(user.id, updates)
    if (updatedProfile) {
      setProfile(updatedProfile)
    }
  }

  if (loading) return <div>Loading...</div>

  return (
    <div>
      <h1>Profile</h1>
      {/* Profile form here */}
    </div>
  )
}
```

---

## 📋 12. Key Commands & Scripts

### Generate Types
```bash
# Install Supabase CLI
npm install -g supabase

# Login to Supabase
supabase login

# Generate types
npx supabase gen types typescript --project-id your-project-id > src/lib/supabase/types.ts
```

### Package.json Scripts
```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "types:generate": "npx supabase gen types typescript --project-id your-project-id > src/lib/supabase/types.ts"
  }
}
```

---

## 🛠️ 13. Development Tips

### Environment Variables
- Always use `NEXT_PUBLIC_` prefix for client-side variables
- Keep service role key server-side only
- Use different environments for development/production

### Type Safety
- Always generate types after schema changes
- Use TypeScript strict mode
- Define custom types for complex operations

### Security
- Enable RLS on all tables
- Create specific policies for different user roles
- Validate file uploads on both client and server
- Use server-side validation for sensitive operations

### Performance
- Use React Query for data fetching
- Implement proper loading states
- Cache static data when possible
- Optimize images with Next.js Image component

---

## 🚀 14. Deployment Checklist

- [ ] Environment variables configured
- [ ] Database schema deployed
- [ ] Storage buckets created
- [ ] RLS policies enabled
- [ ] Auth providers configured
- [ ] Domain configured for auth redirects
- [ ] File upload limits set
- [ ] Error monitoring setup
- [ ] Types generated and committed

---

## 📚 15. Additional Resources

- [Supabase Documentation](https://supabase.com/docs)
- [Next.js Auth Helpers](https://supabase.com/docs/guides/auth/auth-helpers/nextjs)
- [Supabase CLI](https://supabase.com/docs/reference/cli)
- [Row Level Security](https://supabase.com/docs/guides/auth/row-level-security)
- [Storage Management](https://supabase.com/docs/guides/storage)

This comprehensive guide provides everything needed to set up a full-featured Supabase integration in a Next.js project with authentication, database operations, file uploads, and type safety. Adapt the examples to your specific use case and requirements.
